name: Pull Request Checks

on:
  pull_request:
    branches: [ main, develop ]
    types: [opened, synchronize, reopened, ready_for_review]

env:
  NODE_VERSION: '18.17.0'

jobs:
  # Job 1: Skip if draft PR
  check-pr-status:
    name: Check PR Status
    runs-on: ubuntu-latest
    outputs:
      should_skip: ${{ steps.skip_check.outputs.should_skip }}
    
    steps:
      - name: Skip draft PRs
        id: skip_check
        run: |
          if [ "${{ github.event.pull_request.draft }}" = "true" ]; then
            echo "should_skip=true" >> $GITHUB_OUTPUT
            echo "â­ï¸ Skipping checks for draft PR"
          else
            echo "should_skip=false" >> $GITHUB_OUTPUT
            echo "âœ… Running checks for ready PR"
          fi

  # Job 2: Code quality checks
  code-quality:
    name: Code Quality
    runs-on: ubuntu-latest
    needs: check-pr-status
    if: needs.check-pr-status.outputs.should_skip == 'false'
    
    steps:
      - name: Checkout PR code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci --prefer-offline --no-audit

      - name: Run ESLint with annotations
        run: |
          npx eslint src/ --ext .js,.jsx --format @microsoft/eslint-formatter-sarif --output-file eslint-results.sarif || true
          npx eslint src/ --ext .js,.jsx

      - name: Upload ESLint results to GitHub
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: eslint-results.sarif
          wait-for-processing: true

      - name: Check code formatting
        run: |
          # Check if prettier is configured
          if [ -f ".prettierrc" ] || [ -f ".prettierrc.json" ] || [ -f "prettier.config.js" ]; then
            npx prettier --check "src/**/*.{js,jsx,json,css,md}"
          else
            echo "âš ï¸ Prettier not configured, skipping format check"
          fi

  # Job 3: Build verification
  build-check:
    name: Build Verification
    runs-on: ubuntu-latest
    needs: check-pr-status
    if: needs.check-pr-status.outputs.should_skip == 'false'
    
    steps:
      - name: Checkout PR code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci --prefer-offline --no-audit

      - name: Build application
        run: npm run build:prod
        env:
          CI: false
          GENERATE_SOURCEMAP: false

      - name: Check build size
        run: |
          BUILD_SIZE=$(du -sh build | cut -f1)
          echo "ðŸ“¦ Build size: $BUILD_SIZE"
          
          # Check if build size is reasonable (under 50MB)
          BUILD_SIZE_BYTES=$(du -sb build | cut -f1)
          MAX_SIZE=$((50 * 1024 * 1024))  # 50MB in bytes
          
          if [ $BUILD_SIZE_BYTES -gt $MAX_SIZE ]; then
            echo "âš ï¸ Build size ($BUILD_SIZE) exceeds 50MB threshold"
            echo "Consider optimizing bundle size"
          else
            echo "âœ… Build size is within acceptable limits"
          fi

  # Job 4: Test execution
  test-execution:
    name: Test Execution
    runs-on: ubuntu-latest
    needs: check-pr-status
    if: needs.check-pr-status.outputs.should_skip == 'false'
    
    steps:
      - name: Checkout PR code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci --prefer-offline --no-audit

      - name: Run tests with coverage
        run: npm run test:ci
        env:
          CI: true

      - name: Generate coverage report
        run: |
          if [ -f "coverage/lcov.info" ]; then
            COVERAGE=$(npx lcov-summary coverage/lcov.info | grep "Total Coverage" | awk '{print $3}' || echo "N/A")
            echo "ðŸ“Š Test coverage: $COVERAGE"
            echo "COVERAGE=$COVERAGE" >> $GITHUB_ENV
          fi

      - name: Comment coverage on PR
        uses: actions/github-script@v7
        if: env.COVERAGE != ''
        with:
          script: |
            const coverage = process.env.COVERAGE;
            const body = `## ðŸ“Š Test Coverage Report
            
            **Coverage:** ${coverage}
            
            <details>
            <summary>View detailed coverage report</summary>
            
            Coverage report is available in the workflow artifacts.
            </details>`;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            });

  # Job 5: Security scan
  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    needs: check-pr-status
    if: needs.check-pr-status.outputs.should_skip == 'false'
    
    steps:
      - name: Checkout PR code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci --prefer-offline --no-audit

      - name: Run security audit
        run: |
          npm audit --audit-level=moderate --json > audit-results.json || true
          
          # Check for high/critical vulnerabilities
          HIGH_VULNS=$(cat audit-results.json | jq '.metadata.vulnerabilities.high // 0')
          CRITICAL_VULNS=$(cat audit-results.json | jq '.metadata.vulnerabilities.critical // 0')
          
          echo "ðŸ” Security audit results:"
          echo "High vulnerabilities: $HIGH_VULNS"
          echo "Critical vulnerabilities: $CRITICAL_VULNS"
          
          if [ "$HIGH_VULNS" -gt 0 ] || [ "$CRITICAL_VULNS" -gt 0 ]; then
            echo "âš ï¸ High or critical vulnerabilities found!"
            npm audit --audit-level=moderate
            exit 1
          else
            echo "âœ… No high or critical vulnerabilities found"
          fi

  # Job 6: Changed files analysis
  changed-files:
    name: Changed Files Analysis
    runs-on: ubuntu-latest
    needs: check-pr-status
    if: needs.check-pr-status.outputs.should_skip == 'false'
    
    steps:
      - name: Checkout PR code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get changed files
        id: changed-files
        uses: tj-actions/changed-files@v41
        with:
          files: |
            src/**/*.js
            src/**/*.jsx
            package.json
            package-lock.json

      - name: Analyze changes
        run: |
          echo "ðŸ“ Changed files in this PR:"
          echo "${{ steps.changed-files.outputs.all_changed_files }}"
          
          # Check if package.json was modified
          if echo "${{ steps.changed-files.outputs.all_changed_files }}" | grep -q "package.json"; then
            echo "âš ï¸ package.json was modified - ensure package-lock.json is updated"
          fi
          
          # Count changed files
          CHANGED_COUNT=$(echo "${{ steps.changed-files.outputs.all_changed_files }}" | wc -w)
          echo "ðŸ“Š Total files changed: $CHANGED_COUNT"
          
          if [ $CHANGED_COUNT -gt 50 ]; then
            echo "âš ï¸ Large PR detected ($CHANGED_COUNT files changed)"
            echo "Consider breaking this into smaller PRs for easier review"
          fi

  # Job 7: PR summary
  pr-summary:
    name: PR Summary
    runs-on: ubuntu-latest
    needs: [code-quality, build-check, test-execution, security-scan, changed-files]
    if: always() && needs.check-pr-status.outputs.should_skip == 'false'
    
    steps:
      - name: Generate PR summary
        uses: actions/github-script@v7
        with:
          script: |
            const jobs = [
              { name: 'Code Quality', status: '${{ needs.code-quality.result }}' },
              { name: 'Build Check', status: '${{ needs.build-check.result }}' },
              { name: 'Test Execution', status: '${{ needs.test-execution.result }}' },
              { name: 'Security Scan', status: '${{ needs.security-scan.result }}' },
              { name: 'Changed Files', status: '${{ needs.changed-files.result }}' }
            ];
            
            const getEmoji = (status) => {
              switch(status) {
                case 'success': return 'âœ…';
                case 'failure': return 'âŒ';
                case 'cancelled': return 'â¹ï¸';
                case 'skipped': return 'â­ï¸';
                default: return 'â³';
              }
            };
            
            const summary = jobs.map(job => 
              `${getEmoji(job.status)} **${job.name}**: ${job.status}`
            ).join('\n');
            
            const allPassed = jobs.every(job => job.status === 'success');
            const overallStatus = allPassed ? 'ðŸŽ‰ All checks passed!' : 'âš ï¸ Some checks failed';
            
            const body = `## ðŸ” PR Check Summary
            
            ${overallStatus}
            
            ### Check Results
            ${summary}
            
            ${allPassed ? 
              'âœ… This PR is ready for review and merge!' : 
              'âŒ Please address the failing checks before merging.'
            }
            
            ---
            *Automated PR checks completed*`;
            
            // Find existing comment
            const comments = await github.rest.issues.listComments({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
            });
            
            const existingComment = comments.data.find(comment => 
              comment.user.login === 'github-actions[bot]' && 
              comment.body.includes('PR Check Summary')
            );
            
            if (existingComment) {
              // Update existing comment
              await github.rest.issues.updateComment({
                comment_id: existingComment.id,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: body
              });
            } else {
              // Create new comment
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: body
              });
            }